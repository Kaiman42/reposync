#!/usr/bin/env python3
import os, stat, sys
from typing import Iterable, Optional
try:
    from version import HOOK_VERSION
except Exception:
    HOOK_VERSION = "0.0.0"

BASES = ['/home/kaiman/Repos/Meus', '/home/kaiman/Repos/Terceiros']
# Caminho absoluto para o script principal (evita depender de $PWD dentro do hook)
REPOSYNC = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'bin', 'reposync.py')
HOOKS = [
    'post-commit',
    'post-merge',
    'post-checkout',
    'post-rewrite',
    'post-applypatch',
    'post-reset',
    'post-update',  # fetch/pull via server update (bare/server side, pode ser ignorado localmente)
    'post-switch'   # git switch (git 2.23+)
]

# Template do hook. Passamos explicitamente o caminho do repositório para o script.
HOOK_TEMPLATE = """#!/bin/bash
# Auto-generated by install_hooks.py (reposync)
# hook-version: {hook_version}
REPO_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
"{reposync}" "$REPO_DIR" --ensure-hooks -q >/dev/null 2>&1 &
exit 0
"""

def is_repo(path):
    return os.path.isdir(os.path.join(path, '.git'))

def iter_repos(bases: Optional[Iterable[str]] = None):
    bases = list(bases) if bases else BASES
    for base in bases:
        if os.path.isdir(base):
            for name in os.listdir(base):
                p = os.path.join(base, name)
                if is_repo(p):
                    yield p

def ensure_executable(path):
    st = os.stat(path)
    os.chmod(path, st.st_mode | stat.S_IEXEC)

def write_hook(repo, hook):
    hooks_dir = os.path.join(repo, '.git', 'hooks')
    os.makedirs(hooks_dir, exist_ok=True)
    hook_path = os.path.join(hooks_dir, hook)
    script = HOOK_TEMPLATE.format(reposync=REPOSYNC, hook_version=HOOK_VERSION)
    with open(hook_path, 'w') as f:
        f.write(script)
    ensure_executable(hook_path)
    return hook_path

def repo_hook_version(repo: str) -> str:
    sample = os.path.join(repo, '.git', 'hooks', 'post-commit')
    if not os.path.isfile(sample):
        return ""
    try:
        with open(sample, 'r') as f:
            for line in f:
                if line.startswith('# hook-version:'):
                    return line.split(':',1)[1].strip()
    except Exception:
        return ""
    return ""

def needs_update(repo: str) -> bool:
    return repo_hook_version(repo) != HOOK_VERSION

def install_for_repo(repo: str, force: bool=False):
    if not force and not needs_update(repo):
        return False
    for hook in HOOKS:
        write_hook(repo, hook)
    return True

def main(argv=None):
    argv = argv or sys.argv[1:]
    force = False
    only = []
    for a in argv:
        if a in ('-f','--force'):
            force = True
        else:
            only.append(a)
    bases = []
    explicit_repos = []
    for item in only:
        if os.path.isdir(os.path.join(item, '.git')):
            explicit_repos.append(os.path.abspath(item))
        elif os.path.isdir(item):
            bases.append(os.path.abspath(item))
    targets = set(explicit_repos)
    if bases or not targets:
        for r in iter_repos(bases if bases else None):
            targets.add(r)
    updated = 0
    skipped = 0
    for repo in sorted(targets):
        if install_for_repo(repo, force=force):
            print(f'[UPDATED] {repo}')
            updated += 1
        else:
            print(f'[OK] {repo} (versão atual {HOOK_VERSION})')
            skipped += 1
    print(f'Concluído. Atualizados: {updated} | Pulados: {skipped} | Total: {updated+skipped}')

if __name__ == '__main__':
    main()
